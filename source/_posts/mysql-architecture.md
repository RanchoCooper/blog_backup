---
title: MySQL架构
subtitle: MySQL Architecture
date: 2017-07-22 02:04:12
catalog: true
tags:
    - 编程札记
    - 高性能MySQL
---

> MySQL不够完美，但却足够灵活。

MySQL最与众不同的特性是它的存储引擎架构，它将查询处理(Query Processing)于其他子系统单独隔离。这种处理和存储分离的设计可以在使用时根据环境特性来按需选择数据存储的方式。

# 逻辑架构
![逻辑架构](mysql-architecture.jpg)

可以看到，其架构分为三层。三层的功能分别为：

- 服务层：连接处理，授权认证，安全等大多数基于网络的工具都会提供的功能。
- 核心层：查询解析，分析优化，缓存，以及跨存储引擎的功能(存储过程，触发器，视图等)。
- 引擎层：存储引擎。类似各种文件系统，不同的存储引擎都有各自的优缺点。不同引擎间不会相互通信，仅仅响应上层的服务请求。引擎接口对外是透明的。

每个客户端连接都会在服务器进程中拥有一个线程，在该连接中进行的查询操作只会在这个单独的线程环境中执行。5.5之后支持线程池插件，可以通过少量线程来处理大量连接。响应一个查询请求时，MySQL会解析查询，创建内部解析树，并对其进行各种优化，包括重写查询，决定表的读取顺序，以及选择适合的索引。对SELECT查询，会在解析之前检查查询缓存(Query Cache)。如果能找到对应的查询，便不再进行查询解析，优化和执行等过程，直接返回查询缓存中的结果。

# 并发控制
当有多个查询在同一时刻修改数据，就会产生并发控制的问题。这个问题通过实现共享锁和排他锁即可解决，即读锁和写锁。读锁是互不干扰的，即保证了多个查询可以同时读取同一个资源。而写锁则会则塞其他读锁和写锁对资源的访问，这样才能避免同时写入数据的发生。

实现锁带来的另一个问题是加锁需要耗费额外资源，获得锁，检查锁，释放锁等操作，都会增加系统的开销。锁粒度越小，系统的并发程度就越高。良好的锁策略，应该是在锁开销和数据安全性之间寻求平衡。

表锁和行锁是数据库中常见的两种锁策略。

# 事务
一个运行良好的事务处理系统，应该具备ACID特性。

- 原子性(atomicity)：事务是最小的工作单元，其中的操作要么全部执行，要么中途失败，全部回滚。
- 一致性(consistency)：保证事务状态的独立，不存在逻辑上的混杂。
- 隔离性(isolation)：在事务完成之前，对外不可见。
- 持久性(durability)：保证事务一旦提交，其修改便能存至数据库。

SQL标准中定义了四种隔离级别：
- 未提交读：修改而未提交的事务，对外可见。(脏读)
- 提交读：当事务提交后，其修改才对外可见。大部分数据库的默认隔离级别。(不可重复读，在同一事务中先后执行同样的查询，结果可能不一致)
- 可重复读：保证在同一事务多次读取同样记录的结果是一致的。(解决了脏读，但无法解决幻读)
- 可串行化：最高级别的隔离，通过强制事务串行执行，避免了幻读。实际中一般不考虑。

# 其他
InnoDB是MySQL的默认事务型引擎，此外它还内建多种引擎，支持插件式的引擎API。

面对不同需求和应用场景要选择合适引擎。
